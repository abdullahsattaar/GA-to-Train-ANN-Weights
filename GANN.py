# -*- coding: utf-8 -*-
"""AI_6D_Project_19L1243_19L1247_19L-1248.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w_arwZytodfIMg59BMYfLMEyV6ayI63Q
"""

'''Artificial Intelligence 6D Project'''
''' GROUP MEMBERS'''
# 19L-1243, 19L-1247, 19L-1248

'''_____________________________________________________________________________'''

#Libraries
import random
import numpy as np
import pandas as pd
import copy
import time
from sklearn.preprocessing import OneHotEncoder
#_______________________________________________________________________________

# Network Class
class Network(object):

    def __init__(self, sizes):
        
        '''The biases and weights for the
        network are initialized randomly,between 0 to 1.'''

        self.num_layers = len(sizes)
        self.sizes = sizes
        self.biases = [np.random.randn(y, 1) for y in sizes[1:]]
        self.weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])]
        
        # helper variables
        self.bias_nitem = sum(sizes[1:])
        self.weight_nitem = sum([self.weights[i].size for i in range(self.num_layers-2)])
    
    #Feed Forward Function
    def feedforward(self, a):        
        for b, w in zip(self.biases, self.weights):
            a = self.sigmoid(np.dot(w,a)+b)
        return a   
        #Return the output of the network

    # Sigmoid Function
    def sigmoid(self, z):
        return 1.0/(1.0+np.exp(-z))

    def score(self, features, label):
        total_score=0
        for i in range(features.shape[0]):
            predicted = self.feedforward(features[i].reshape(-1,1))
            actual = label[i].reshape(-1,1)
            total_score += np.sum(np.power(predicted-actual,2)/2)  # mean-squared error
        return total_score
        #returns score of network prediction (less is better)
    
    #Accuracy Funtion
    def accuracy(self, features, label):
        accuracy = 0
        for i in range(features.shape[0]):
            output = self.feedforward(features[i].reshape(-1,1))
            accuracy += int(np.argmax(output) == np.argmax(label[i]))
        return accuracy / features.shape[0] * 100 
        #returns accuracy (%) (more is better)     


    def __str__(self):
        s = "\nBias:\n\n" + str(self.biases)
        s += "\nWeights:\n\n" + str(self.weights)
        s += "\n\n"
        return s
#_______________________________________________________________________________

# Class Nueral Network Genetic Algorithm
class NNGA:

    def __init__(self, popsize, networksize, mutationrate, crossoverrate, selectionrate, features, label):
      
        self.n_pops = popsize  #population size for GA
        self.net_size = networksize #ANN Size
        self.nets = [Network(self.net_size) for i in range(self.n_pops)]
        self.mutation_rate = mutationrate
        self.crossover_rate = crossoverrate
        self.selectionrate = selectionrate
        self.features = features[:]  #Our data to test accuracy
        self.label = label[:]   #Our label to test accuracy
    
    def get_random_point(self, type):

   #note: if type is set to 'weight', point_index will return (row_index, col_index)

        nn = self.nets[0]
        layer_index, point_index = random.randint(0, nn.num_layers-2), 0
        if type == 'weight':
            row = random.randint(0,nn.weights[layer_index].shape[0]-1)
            col = random.randint(0,nn.weights[layer_index].shape[1]-1)
            point_index = (row, col)
        elif type == 'bias':
            point_index = random.randint(0,nn.biases[layer_index].size-1)
        return (layer_index, point_index)

    def get_all_scores(self):
        return [net.score(self.features, self.label) for net in self.nets]

    def get_all_accuracy(self):
        return [net.accuracy(self.features, self.label) for net in self.nets]

    def crossover(self, father, mother):

        # make a copy of father 'genetic' weights & biases information
        fatherscopy = copy.deepcopy(father)

        # cross-over bias
        for _ in range(self.nets[0].bias_nitem):
            # get some random points
            layer, point = self.get_random_point('bias')
            # replace genetic (bias) with mother's value
            if random.uniform(0,1) < self.crossover_rate:
                fatherscopy.biases[layer][point] = mother.biases[layer][point]

        # cross-over weight
        for _ in range(self.nets[0].weight_nitem):
            # get some random points
            layer, point = self.get_random_point('weight')
            # replace genetic (weight) with mother's value
            if random.uniform(0,1) < self.crossover_rate:
                fatherscopy.weights[layer][point] = mother.weights[layer][point]
        child= fatherscopy
        return child
        #returns new child based on father/mother genetic information
        
    def mutation(self, child):

        childscopy= copy.deepcopy(child)

        # mutate bias
        for _ in range(self.nets[0].bias_nitem):
            # get some random points
            layer, point = self.get_random_point('bias')
            # add some random value between -0.5 and 0.5
            if random.uniform(0,1) < self.mutation_rate:
                childscopy.biases[layer][point] += random.uniform(-0.5, 0.5)

        # mutate weight
        for _ in range(self.nets[0].weight_nitem):
            # get some random points
            layer, point = self.get_random_point('weight')
            # add some random value between -0.5 and 0.5
            if random.uniform(0,1) < self.mutation_rate:
                childscopy.weights[layer][point[0], point[1]] += random.uniform(-0.5, 0.5)
        mutated=childscopy
        return mutated
        # returns new mutated neural-net

    def evolve(self):

        # calculate score for each population of neural-net
        score_list = list(zip(self.nets, self.get_all_scores()))

        # sort the network using its score
        score_list.sort(key=lambda x: x[1])

        # exclude score as it is not needed anymore
        score_list = [obj[0] for obj in score_list]

        # keep only the best one
        fittest = int(self.n_pops*self.selectionrate)
        score_list_top = score_list[:fittest]

        # return some non-best ones
        notfittest = int((self.n_pops-fittest) * self.selectionrate)
        for _ in range(random.randint(0, notfittest)):
            score_list_top.append(random.choice(score_list[fittest:]))

        # breed new childs if current population number less than what we want
        while len(score_list_top) < self.n_pops:

            father = random.choice(score_list_top)
            mother = random.choice(score_list_top)

            if father != mother:
                new_child = self.crossover(father, mother)
                new_child = self.mutation(new_child)
                score_list_top.append(new_child)
        
        # copy our new population to current object
        self.nets = score_list_top
#_______________________________________________________________________________

# Main Function
def main():

    # load data from iris dataset.csv into features and label
    df = pd.read_csv("iris dataset.csv")
    features = df.iloc[:, :-1].values
    label = df.iloc[:, -1].values

    # convert label into one-hot encoded format
    label = label.reshape(-1, 1)
    he = OneHotEncoder()
    he.fit(label)
    label = he.transform(label).toarray()

    # parameters
    Populationsize = 100
    Networksize = [4,5,5,3]  # This ANN contain 4 Layes 1st is input, then 2 hidden Layers and 1 output layer.
    Mutationrate = 0.2
    Crossoverrate = 0.4
    Selectionrate = 0.4

    # start our neural-net & optimize it using genetic algorithm
    ann = NNGA(Populationsize, Networksize, Mutationrate, Crossoverrate, Selectionrate, features, label)
    
    # run for n iterations
    for i in range(1000):

        #if i % 10 == 0:
        print("Current iteration :",i+1)
        print("Current Network Accuracy: " , ann.get_all_accuracy()[0], "%\n")
        if ann.get_all_accuracy()[0]> 97:
          print("Current iteration :",i+1)
          print("Current Network Accuracy: " , ann.get_all_accuracy()[0], "%\n")
          break 

        # evolve the population
        ann.evolve()
#_______________________________________________________________________________

#Run the Main()
print("********************************************")
print("Artificial Intelligence 6D")
print("POJECT: GA to learn weights of ANN.")
print("GROUP MEMBERS: 19L-1243 RAAHIM AHMAD KHAN")
print("19L-1243 RAAHIM AHMAD KHAN")
print("19L-1247 SYED DAUD RIZVI")
print("19L-1248 MUHAMMAD ABDULLAH SATTAR\n")
print("*********************STARTING NETWORK**********************\n")
main()
print("***** Thanks Goodbye *****")
#_______________________________________________________________________________